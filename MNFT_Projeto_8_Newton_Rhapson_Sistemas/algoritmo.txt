/***********************************************
 * \brief   Programa realizado para a Aula de Métodos Númericos em Fenômenos de Transporte
 *          Análise Numérica - Burden, Richard - 10ª edição - Pág. 716
 *          Algoritmo 10.1 - Método de Newton-Rhapson para Solução de Sistemas de Equações Não Lineares
 *
 * \param   Número de Equações n
 * \param   Aproximações Iniciais x[n]
 * \return  Solução Aproximada x[n]
 *
 ***********************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <locale.h>
#define max(a,b) (a > b) ? a : b    /*função máximo*/
#define tol 10e-16                  /*valor mínimo de tolerância = 10e-16*/
#define n_max 100                   /*valor máximo para iterações = 100*/

/*declaração das funções*/
void esc_piv(int, double **, int *, double *);
void sistema(int, double **, int *, double *, double *);
void df(int, int, double *, double **, double);
double funcao(int, double *);

int main(void)
{
	setlocale(LC_ALL,"");

	double **J, *w, *_w, *F, *X;
	int *L;
	int k, i, n;
	double h, erro, erro_max;

	/*Definição do h para o calculo da derivação numérica*/
	h = tol * 10;

	/*Entrada de parâmetros*/
	printf("Digite o número de incógnitas do sistema [n]: "); scanf("%d", &n);

	J = calloc((n+1), sizeof(double *));
	for (i=0; i<=n; i++){J[i] = calloc((n+1), sizeof(double));}
	w = calloc((n+1), sizeof(double));
	_w = calloc((n+1), sizeof(double));
	F = calloc((n+1), sizeof(double));
	X = calloc((n+1), sizeof(double));
	L = calloc((n+1), sizeof(int));

    printf("Digite as aproximações iniciais para o sistema w[n]: \n");
    for (i=1; i<=n; i++){printf("w[%d]= ", i); scanf ("%lf", &w[i]); _w[i] = w[i];}

	for(k=0; k<=n_max; k++)
    {

        /*Exibição dos valores calculados para o usuário*/
        printf("k= %d", k);
        for (i = 1; i <= n; i++){printf("\tw[%d]= %+.8f", i, w[i]);}
        printf("\n");

        /*Cálculo do vetor -F(x)*/
        for (i=1; i<=n; i++){F[i] = - funcao(i, w);}

        /*Cálculo da Matriz Jacobiana*/
        df(k, n, w, J, h);

        /*Cálculo da solução do Sistema Linear*/
        esc_piv(n, J, L, F);
        sistema(n, J, L, F, X);

        /*Cálculo do novo w*/
        for (i=1; i<=n; i++){w[i] = X[i] + w[i];}

        /*Cálculo do Resíduo*/
        erro_max = 0;
        for (i=1; i<=n; i++)
        {
            erro = fabs(funcao(i, w));
            erro_max = max(erro_max, erro);
        }

        /*Critérios de parada*/
        if(erro_max<=tol){printf("\nO método atingiu a tolerância especificada\n"); break;}
        if(k>=n_max){printf("\nO método atingiu o número máximo de iterações especificado\n"); break;}

    }

    printf("\n\nFim do programa\n\n. ");

	for (i=0; i<=n; i++){free(J[i]);}
	free(J); free(w); free(_w); free(F); free(X); free(L);

	system("PAUSE");
	return 0;
}

/*Cálculo dos valores da função*/
double funcao(int f, double *w)
{
    switch (f)
    {
        case 1 :
            /*validação ex. 2 com valores inicias [0.1,0.1,-0.1]*/
            return(3 * w[1] - cos(w[2] * w[3]) - 0.5);
            break;
        case 2:
            /*validação ex. 2 com valores inicias [0.1,0.1,-0.1]*/
            return(pow(w[1], 2) - 81 * pow((w[2] + 0.1), 2) + sin(w[3]) + 1.06);
            break;
        case 3:
            /*validação ex. 2 com valores inicias [0.1,0.1,-0.1]*/
            return(exp(-w[1] * w[2]) + 20 * w[3] + (10 * M_PI - 3) / 3);
            break;
        default:
            return 0;
    }
}

/*Cálculo da Matriz Jacobiana*/
void df(int k, int n, double *w, double **J, double h)
{
    double *_w;
    _w = calloc((n+1), sizeof(double *));
    int i, j, _i;

    for (i = 1; i <= n ; i++)
    {
        for (j = 1; j <= n; j++)
        {
            for (_i = 1; _i <= n; _i++){_w[_i] = w[_i];}
            _w[j] = _w[j] + h;
            J[i][j] = (funcao(i, _w) - funcao(i, w)) / h;
        }
    }
}

/*Pivotamento parcial de colunas com escalonamento*/
void esc_piv(int n, double **A, int *L, double *B)
{
	int i, j, k, _i, _k;
	double S[n+1];
	double xmult, smax, rmax, ratio;

	/*Definição do fator de escala s*/
	for (i = 1; i <= n; i++)
	{
		L[i] = i;
		smax = 0.0;
		for (j = 1; j <= n; j++){smax = max (smax, fabs(A[i][j]));}
        S[i] = smax;
	}

	/*Pivotamento de Colunas com escala */
	for (k = 1; k < n; k++)
	{
		rmax = 0.0;
		for (i = k ; i <= n; i++)
		{
			_i = L[i];
			ratio = fabs(A[_i][k]) / S[_i];
			if (ratio > rmax)
			{
				rmax = ratio;
				j = i;
			}
		}

	/*Troca a referência das linhas*/
	_k = L[j];
	L[j] = L[k];
	L[k] = _k;

		for (i = k+1; i <= n; i++)
		{
			_i = L[i];
			xmult = A[_i][k] / A[_k][k];
			/*printf("\n\tmultiplicador[%d,%d]= %+.8f", i, k, xmult);*/
			A[_i][k] = 0.0;
			for (j = k+1; j<= n; j++){A[_i][j] -= xmult * A[_k][j];}
			B[_i] -= xmult * B[_k];
		}
	}
}

/*Cálculo da solução do sistema linear X*/
void sistema(int n, double **A, int *L, double *B, double *X)
{
	int i, j, k, _i, _k, _n;
	double soma;

	for (k = 1; k < n ; k++)
	{
		_k = L[k];
		for (i = k+1; i <= n; i++)
		{
			_i = L[i];
			B[_i] -= A[_i][k] * B[_k];
		}
	}
	_n = L[n];
	X[n] = B[_n] / A[_n][n];

	for (i = n-1; i>= 1; i--)
	{
		_i = L[i];
		soma = B[_i];
		for (j = i+1; j <= n ; j++){soma -= A[_i][j] * X[j];}
		X[i] = soma / A[_i][i];
	}
}
